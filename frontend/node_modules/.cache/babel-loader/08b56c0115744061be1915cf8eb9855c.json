{"ast":null,"code":"/*\n * exit\n * https://github.com/cowboy/node-exit\n *\n * Copyright (c) 2013 \"Cowboy\" Ben Alman\n * Licensed under the MIT license.\n */\n'use strict';\n\nmodule.exports = function exit(exitCode, streams) {\n  if (!streams) {\n    streams = [process.stdout, process.stderr];\n  }\n\n  var drainCount = 0; // Actually exit if all streams are drained.\n\n  function tryToExit() {\n    if (drainCount === streams.length) {\n      process.exit(exitCode);\n    }\n  }\n\n  streams.forEach(function (stream) {\n    // Count drained streams now, but monitor non-drained streams.\n    if (stream.bufferSize === 0) {\n      drainCount++;\n    } else {\n      stream.write('', 'utf-8', function () {\n        drainCount++;\n        tryToExit();\n      });\n    } // Prevent further writing.\n\n\n    stream.write = function () {};\n  }); // If all streams were already drained, exit now.\n\n  tryToExit(); // In Windows, when run as a Node.js child process, a script utilizing\n  // this library might just exit with a 0 exit code, regardless. This code,\n  // despite the fact that it looks a bit crazy, appears to fix that.\n\n  process.on('exit', function () {\n    process.exit(exitCode);\n  });\n};","map":{"version":3,"names":["module","exports","exit","exitCode","streams","process","stdout","stderr","drainCount","tryToExit","length","forEach","stream","bufferSize","write","on"],"sources":["C:/Users/16145/node_modules/exit/lib/exit.js"],"sourcesContent":["/*\n * exit\n * https://github.com/cowboy/node-exit\n *\n * Copyright (c) 2013 \"Cowboy\" Ben Alman\n * Licensed under the MIT license.\n */\n\n'use strict';\n\nmodule.exports = function exit(exitCode, streams) {\n  if (!streams) { streams = [process.stdout, process.stderr]; }\n  var drainCount = 0;\n  // Actually exit if all streams are drained.\n  function tryToExit() {\n    if (drainCount === streams.length) {\n      process.exit(exitCode);\n    }\n  }\n  streams.forEach(function(stream) {\n    // Count drained streams now, but monitor non-drained streams.\n    if (stream.bufferSize === 0) {\n      drainCount++;\n    } else {\n      stream.write('', 'utf-8', function() {\n        drainCount++;\n        tryToExit();\n      });\n    }\n    // Prevent further writing.\n    stream.write = function() {};\n  });\n  // If all streams were already drained, exit now.\n  tryToExit();\n  // In Windows, when run as a Node.js child process, a script utilizing\n  // this library might just exit with a 0 exit code, regardless. This code,\n  // despite the fact that it looks a bit crazy, appears to fix that.\n  process.on('exit', function() {\n    process.exit(exitCode);\n  });\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,SAASC,IAAT,CAAcC,QAAd,EAAwBC,OAAxB,EAAiC;EAChD,IAAI,CAACA,OAAL,EAAc;IAAEA,OAAO,GAAG,CAACC,OAAO,CAACC,MAAT,EAAiBD,OAAO,CAACE,MAAzB,CAAV;EAA6C;;EAC7D,IAAIC,UAAU,GAAG,CAAjB,CAFgD,CAGhD;;EACA,SAASC,SAAT,GAAqB;IACnB,IAAID,UAAU,KAAKJ,OAAO,CAACM,MAA3B,EAAmC;MACjCL,OAAO,CAACH,IAAR,CAAaC,QAAb;IACD;EACF;;EACDC,OAAO,CAACO,OAAR,CAAgB,UAASC,MAAT,EAAiB;IAC/B;IACA,IAAIA,MAAM,CAACC,UAAP,KAAsB,CAA1B,EAA6B;MAC3BL,UAAU;IACX,CAFD,MAEO;MACLI,MAAM,CAACE,KAAP,CAAa,EAAb,EAAiB,OAAjB,EAA0B,YAAW;QACnCN,UAAU;QACVC,SAAS;MACV,CAHD;IAID,CAT8B,CAU/B;;;IACAG,MAAM,CAACE,KAAP,GAAe,YAAW,CAAE,CAA5B;EACD,CAZD,EATgD,CAsBhD;;EACAL,SAAS,GAvBuC,CAwBhD;EACA;EACA;;EACAJ,OAAO,CAACU,EAAR,CAAW,MAAX,EAAmB,YAAW;IAC5BV,OAAO,CAACH,IAAR,CAAaC,QAAb;EACD,CAFD;AAGD,CA9BD"},"metadata":{},"sourceType":"script"}